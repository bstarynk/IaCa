// file iaca.hh
#ifndef IACA_INCLUDED_
#define IACA_INCLUDED_
// Â© 2016 Basile Starynkevitch
//   this file iaca.hh is part of IaCa
//   IaCa is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   IaCa is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with IaCa.  If not, see <http://www.gnu.org/licenses/>.
#define _GNU_SOURCE 1

#include <cassert>
#include <cstdlib>
#include <cstdint>
#include <cctype>
#include <fstream>
#include <cmath>
#include <set>
#include <vector>
#include <map>
#include <memory>
#include <random>
#include <exception>
#include <algorithm>
#include <functional>


#include <QApplication>
#include <QCommandLineParser>
#include <QHash>
#include <QString>
#include <QChar>

/// jsoncpp https://github.com/open-source-parsers/jsoncpp
#include <json/json.h>

// generated by the Makefile in file _timestamp.c
extern "C" const char iaca_timestamp[]; /// human readable timestamp
extern "C" long long iaca_timeclock; // time from Unix Epoch (Jan 1, 1970)
extern "C" const char iaca_lastgitcommit[];
extern "C" const char iaca_lastgittag[];

namespace Iaca {
// forward declarations
class Value;
class Payload;
class ItemVal;

enum class ValKind :uint8_t {
    Nil,
    Int,
    Dbl,
    Str,
    Item,
    Tuple,
    Set,
};

extern bool batch;

struct ItemPtr : public std::shared_ptr<ItemVal> {
    inline Json::Value to_json(void) const;
    inline void scan_items(std::function<bool(ItemVal*)>) ;
    static inline bool same(const ItemPtr ip1, const ItemPtr ip2)
    {
        return ip1.get() == ip2.get();
    };
    static inline bool less(const ItemPtr ip1, const ItemPtr ip2);
    bool operator == (const ItemPtr ipr) const {
        return same(*this,ipr);
    };
    bool operator < (const ItemPtr ipr) const {
        return less (*this,ipr);
    };
    ValKind kind() const {
        return get()?ValKind::Item:ValKind::Nil;
    };
};

struct ValuePtr : public std::shared_ptr<Value> {
    inline Json::Value to_json(void) const;
    inline ValKind kind(void) const;
    inline void scan_items(std::function<bool(ItemVal*)>) ;
    static bool same(const ValuePtr vp1, const ValuePtr vp2);
    static bool less(const ValuePtr vp1, const ValuePtr vp2);
    bool operator == (const ValuePtr vpr) const {
        return same(*this,vpr);
    };
    bool operator < (const ValuePtr vpr) const {
        return less (*this,vpr);
    };
};

class Value {
public:
    // every value has these
    virtual ValKind kind(void) const =0;
    virtual Json::Value to_json(void) const=0;
    virtual uint hash(void) const =0;
    virtual void scan_items(std::function<bool(ItemVal*)> scanfun)= 0;
    virtual ~Value() {};
    // a subtype T of Value also has
    /// static bool same(const T*v1, const T*v2);
    template<typename T> static bool same_val(const T*v1, const T*v2);
    /// static bool less(const T*v1, const T*v2);
    template<typename T> static bool less_val (const T*v1, const T*v2);
    template<typename T>struct less_st {
        bool operator () (const T*v1, const T*v2) {
            return less_val<T>(v1,v2);
        }
    };
};

class IntVal : public Value {
    const intptr_t _ival;
public:
    intptr_t val() const {
        return _ival;
    };
    virtual ValKind kind() const {
        return ValKind::Int;
    };
    virtual void scan_items(std::function<bool(ItemVal*)>) {};
    virtual uint hash(void) const {
        uint h = qHash(_ival);
        if (!h) h = ((_ival&0xffff)+3);
        return h;
    }
    virtual Json::Value to_json(void) const {
        return Json::Int64 {val()};
    };
    static bool same(const IntVal*i1, const IntVal*i2) {
        if (i1==i2) return true;
        if (!i1 || !i2) return false;
        return i1->_ival == i2->_ival;
    }
    static bool less(const IntVal*i1, const IntVal*i2) {
        if (i1==i2) return false;
        if (!i1) return true;
        if (!i2) return false;
        return i1->_ival < i2->_ival;
    };
    IntVal(intptr_t i=0): _ival(i) {};
    virtual ~IntVal() {  };
};				// end class IntVal
template<>
inline bool Value::same_val<IntVal> (const IntVal*i1, const IntVal*i2)
{
    return IntVal::same(i1,i2);
};
template<>
inline bool Value::less_val<IntVal>(const IntVal*i1, const IntVal*i2)
{
    return IntVal::less(i1,i2);
};

class DblVal : public Value {
    const double _dval;
public:
    virtual ValKind kind() const {
        return ValKind::Dbl;
    };
    virtual void scan_items(std::function<bool(ItemVal*)>) {};
    double val() const {
        return _dval;
    };
    DblVal(double d=0): _dval(d) {};
    virtual ~DblVal() {  };
    virtual uint hash(void) const {
        uint h = qHash(_dval);
        if (!h) h = 317;
        return h;
    };
    virtual Json::Value to_json(void) const {
        return val();
    };
    static bool same(const DblVal*d1, const DblVal*d2) {
        if (d1==d2) return true;
        if (!d1 || !d2) return false;
        // for doubles, NAN != NAN, so x != x is true when x is NAN
        return d1->_dval == d2->_dval
               || (std::isnan(d1->_dval)&&std::isnan(d2->_dval));
    }
    // special care for NAN
    static bool less(const DblVal*d1, const DblVal*d2) {
        if (d1==d2) return false;
        if (!d1) return true;
        if (!d2) return false;
        double x1 = d1->_dval;
        double x2 = d2->_dval;
        if (x1 <= x2) return true;
        if (x1 > x2) return false;
        if (std::isnan(x1) && std::isnan(x2)) return false;
        if (std::isnan(x1)) return true;
        if (std::isnan(x2)) return false;
        return x1 < x2;
    };
};
template<>
inline bool Value::same_val<DblVal> (const DblVal*d1, const DblVal*d2)
{
    return DblVal::same(d1,d2);
};
template<>
inline bool Value::less_val<DblVal>(const DblVal*d1, const DblVal*d2)
{
    return DblVal::less(d1,d2);
};

enum class StrCategory :uint8_t {
    None,
    Word,			// has only letters
    Ident,			// C-ident like
    Plain			// other
};
class StrVal : public Value {
    static uint hash_qstring (const QString&qs) {
        uint h = qHash(qs);
        if (!h) h = 2+((3*qs.size()+11)&0xfffff);
        return h;
    }
    const QString _sval;
    const StrCategory _scat;
    const uint _shash;
public:
    static StrCategory category(const QString&qs);
    static StrCategory category(const char*pc);
    StrVal(const QString&qs)
        : _sval(qs),
          _scat(category(qs)),
          _shash(hash_qstring(qs)) {};
    StrVal(const std::string& s)
        : _sval(s.c_str()),
          _scat(category(s.c_str())),
          _shash(hash_qstring(_sval)) {};
    ~StrVal() {};
    StrCategory category(void) const {
        return _scat;
    };
    const QString& val(void) const {
        return _sval;
    };
    virtual void scan_items(std::function<bool(ItemVal*)>) {};
    virtual uint hash(void) const {
        return _shash;
    };
    virtual Json::Value to_json(void) const {
        return Json::Value {val().toStdString()};
    };
    virtual ValKind kind() const {
        return ValKind::Str;
    };
    static StrVal* make(const QString&q) {
        if (q.isEmpty()) return nullptr;
        return new StrVal(q);
    };
    static StrVal* make(const std::string&s) {
        if (s.empty()) return nullptr;
        return new StrVal(s);
    };
    static bool same(const StrVal*s1, const StrVal*s2) {
        if (s1==s2) return true;
        if (!s1 || !s2) return false;
        return s1->_sval == s2->_sval;
    }
    static bool less(const StrVal*s1, const StrVal*s2) {
        if (s1==s2) return false;
        if (!s1) return true;
        if (!s2) return false;
        return s1->_sval < s2->_sval;
    }
};
template<>
inline bool Value::same_val<StrVal> (const StrVal*s1, const StrVal*s2)
{
    return StrVal::same(s1,s2);
};
template<>
inline bool Value::less_val<StrVal>(const StrVal*s1, const StrVal*s2)
{
    return StrVal::less(s1,s2);
};


class SeqItemsVal : public Value {
    static uint hash_itemsarr( ItemVal* arr[], unsigned siz, unsigned seed=0);
protected:
    const uint _shash;
    const unsigned _slen;
    ItemVal**_sarr;
    uint seq_hash () const {
        return _shash;
    };
    SeqItemsVal(ItemVal* arr[], unsigned siz, unsigned seed)
        : _shash(hash_itemsarr(arr,siz,seed)),
          _slen(siz),
          _sarr(new ItemVal*[siz]) {
        for (unsigned ix=0; ix<siz; ix++) _sarr[ix] = arr[ix];
    };
    ~SeqItemsVal() {
        delete[] _sarr;
    };
    virtual void scan_items(std::function<bool(ItemVal*)>scanfun)
    {
        for (unsigned ix=0; ix<_slen; ix++)
            if (!scanfun(_sarr[ix])) return;
    }
    static bool same(const SeqItemsVal*sq1, const SeqItemsVal*sq2) {
        if (sq1 == sq2) return true;
        if (!sq1 || !sq2) return false;
        if (sq1->_slen != sq2->_slen) return false;
        if (sq1->_shash != sq2->_shash) return false;
        unsigned l = sq1->_slen;
        for (unsigned ix=0; ix<l; ix++) if (sq1->_sarr[ix] != sq2->_sarr[ix]) return false;
        return true;
    }
    static bool less(const SeqItemsVal*sq1, const SeqItemsVal*sq2);
public:
    unsigned size() const {
        return _slen;
    };
    ItemVal* unsafe_at(unsigned ix) const {
        return _sarr[ix];
    };
};

class TupleVal : public SeqItemsVal {
    static constexpr const unsigned seed = 431;
    TupleVal( ItemVal*arr[], unsigned siz)
        : SeqItemsVal(arr,siz,seed) {};
    // the item pointers below are never null
    static const TupleVal*make_it(std::vector<ItemVal*>vecptr);
    static const TupleVal*make_it(ItemVal**arr, unsigned siz);
public:
    static void add(std::vector<ItemVal*>&vec, ValuePtr val);
    static void add(std::vector<ItemVal*>&vec, ItemPtr val);
    virtual ~TupleVal() {};
    virtual ValKind kind() const {
        return ValKind::Tuple;
    };
    virtual uint hash(void) const {
        return _shash;
    };
    virtual Json::Value to_json(void) const;
    static bool same(const TupleVal*tu1, const TupleVal*tu2) {
        return SeqItemsVal::same(tu1,tu2);
    }
    static bool less(const TupleVal*tu1, const TupleVal*tu2) {
        return SeqItemsVal::less(tu1,tu2);
    }
    static const TupleVal*make(std::initializer_list<ItemPtr>il);
    static const TupleVal*make(std::initializer_list<ValuePtr>il);
    static const TupleVal*make(const std::vector<ItemPtr>&vec);
    static const TupleVal*make(const std::vector<ValuePtr>&vec);
    static const TupleVal*make(const std::list<ItemPtr>&lis);
    static const TupleVal*make(const std::list<ValuePtr>&lis);
};
template<>
inline bool Value::same_val<TupleVal> (const TupleVal*tu1, const TupleVal*tu2)
{
    return TupleVal::same(tu1,tu2);
};
template<>
inline bool Value::less_val<TupleVal>(const TupleVal*tu1, const TupleVal*tu2)
{
    return TupleVal::less(tu1,tu2);
};


class SetVal : public SeqItemsVal {
    static constexpr const unsigned seed = 541;
    SetVal( ItemVal*arr[], unsigned siz)
        : SeqItemsVal(arr,siz,seed) {};
    static const SetVal*make_it(std::vector<ItemVal*>vecptr);
    static const SetVal*make_it(std::set<ItemPtr>vecptr);
    static const SetVal*make_it(ItemVal**arr, unsigned siz);
    virtual ~SetVal() {};
public:
    virtual ValKind kind() const {
        return ValKind::Set;
    };
    virtual uint hash(void) const {
        return _shash;
    };
    virtual Json::Value to_json(void) const;
    static bool same(const SetVal*tu1, const SetVal*tu2) {
        return SeqItemsVal::same(tu1,tu2);
    }
    static bool less(const SetVal*tu1, const SetVal*tu2) {
        return SeqItemsVal::less(tu1,tu2);
    }
    static const SetVal*make(std::initializer_list<ItemPtr>il);
    static const SetVal*make(std::initializer_list<ValuePtr>il);
    static const SetVal*make(const std::vector<ItemPtr>&vec);
    static const SetVal*make(const std::set<ItemPtr>&vec);
    static const SetVal*make(const std::vector<ValuePtr>&vec);
    static const SetVal*make(const std::list<ItemPtr>&lis);
    static const SetVal*make(const std::list<ValuePtr>&lis);
};
template<>
inline bool Value::same_val<SetVal> (const SetVal*tu1, const SetVal*tu2)
{
    return SetVal::same(tu1,tu2);
};
template<>
inline bool Value::less_val<SetVal>(const SetVal*tu1, const SetVal*tu2)
{
    return SetVal::less(tu1,tu2);
};


class Payload {
    ItemVal* _owneritem;
public:
    virtual ~Payload() {
        _owneritem = nullptr;
    };
};

class ItemVal : public Value {
    const std::shared_ptr<const StrVal> _iradix;
    const uint64_t _irank;
    uint _ihash;
    std::unique_ptr<Payload> _ipayload;
    std::map<ItemPtr,ValuePtr> _iattrmap;
    static std::map<QString,std::shared_ptr<StrVal>> _radix_dict_;
    static const StrVal*register_radix(const QString&str);
    static const StrVal*find_radix(const QString&str);
    virtual void scan_items(std::function<bool(ItemVal*)>scanfun)
    {
        (void)scanfun(this);
    };
    static uint hash_str_rank(const StrVal*pradix, uint64_t rk)
    {
        if (!pradix)  throw std::runtime_error("nil radix for item");
        uint hr = pradix->hash();
        uint h = (313*hr) ^ (rk*2039);
        if (!h) h = (hr&0xfffff) + 3*(rk&0xffff) + 17;
        return h;
    }
    ItemVal(const StrVal*pradix,uint64_t rk)
        : _iradix(pradix),_irank(rk), _ihash(hash_str_rank(pradix,rk)),
          _ipayload(),
          _iattrmap() {
        if (!pradix) throw std::runtime_error("nil radix for item");
    };
public:
    static bool valid_radix(const QString&);
    virtual uint hash(void) const {
        return _ihash;
    };
    virtual ValKind kind(void) const {
        return ValKind::Item;
    };
    virtual Json::Value to_json(void) const {
        Json::Value js {Json::objectValue};
        js["item"] = _iradix->val().toStdString();
        if (_irank>0) js["irank"] = (Json::Int64)_irank;
        return js;
    };
    static bool same(const ItemVal*it1, const ItemVal*it2) {
        return it1 == it2;
    };
    static bool less(const ItemVal*it1, const ItemVal*it2) {
        if (it1 == it2) return false;
        if (!it1) return true;
        if (!it2) return false;
        if (it1->_iradix == it2->_iradix)
            return it1->_irank < it2->_irank;
        return (it1->_iradix->val() < it2->_iradix->val());
    }
};				// end class ItemVal
template<>
inline bool Value::same_val<ItemVal> (const ItemVal*it1, const ItemVal*it2)
{
    return ItemVal::same(it1,it2);
};
template<>
inline bool Value::less_val<ItemVal>(const ItemVal*it1, const ItemVal*it2)
{
    return ItemVal::less(it1,it2);
};

Json::Value ItemPtr::to_json(void) const {
    const ItemVal*pitm = get();
    if (pitm) return pitm->to_json();
    else return nullptr;
}

void ItemPtr::scan_items(std::function<bool(ItemVal*)>scanfun)  {
    ItemVal*pitm = get();
    if (pitm) (void) scanfun(pitm);
}


bool ItemPtr::less(const ItemPtr ip1, const ItemPtr ip2)
{
    const ItemVal*ptr1 = ip1.get();
    const ItemVal*ptr2 = ip2.get();
    if (ptr1 == ptr2) return false;
    if (!ptr1) return true;
    if (!ptr2) return false;
    return ItemVal::less(ptr1,ptr2);
}

Json::Value ValuePtr::to_json(void) const {
    const Value*pval = get();
    if (pval) return pval->to_json();
    else return nullptr;
}


ValKind ValuePtr::kind(void) const {
    const Value*pval = get();
    if (pval) return pval->kind();
    else return ValKind::Nil;
}

void ValuePtr::scan_items(std::function<bool(ItemVal*)>scanfun)  {
    Value*pval = get();
    if (pval) pval->scan_items(scanfun);
}
};				// end of namespace Iaca
#endif				// IACA_INCLUDED_
